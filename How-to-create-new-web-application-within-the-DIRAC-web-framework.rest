The new DIRAC web framework provides many facilities to develop and test web applications. This framework loads each application in a separate window, and these windows can be arranged at the desktop area  by means of resizing, moving and pinning. In this tutorial we are going to explain the ways of developing and testing new applications.

Before you start this tutorial, it is desirable that you have some experience with programming in Python, JavaScript, HTML, CSS scripting, client-server communication (such as AJAX and web sockets) and sufficient knowledge in object-oriented programming. If you are not familiar with some of the web technologies, or there has been a while since you used those technologies, please visit the W3CSchool web site (http://www.w3schools.com/).  There, you can find tutorials that you can use to learn or to refresh your knowledge for web-programming.

Each application consists of two parts:

- **Client side (CS)**: Builds the user interface and communicates with the web server in order to get necessary data and show it appropriately.
- **Server side (SS)**: Provides services to the client side run in browser.

The folder structure of the server side web installation is as follows:

- <Module name folder such as DIRAC, LHCbDIRAC, WebAppDIRAC>

  - WebApp

    - **handler**: contains all the server side implementations of the framework and all the applications.

    - **static**: contains all the static content that can be loaded by the client side such as JavaScript files, images and css files

      - <Module name folder such as DIRAC, LHCbDIRAC, WebAppDIRAC>: contains the client side implementation of each application

        - Application 1

        - Application 2

        - ...

    - **template**: contains all the templates used by the files in the handler folder

In order to explain how to develop an application, we will go step by step creating an example one. We will name it **MyApp**.

Server Side
-----------------

Each application server side logic is implemented in one Python file. The name of the file is formed by appending the word **Handler** to the name of the application. In the case of the application we want to build, the name of the Python file should be **MyAppHandler**. This file has to be located into the **handler** folder.

Be aware that If this file is not defined in the folder, the application is not going to appear in the main menu.

This file defines a Python class responsible for all server side functionality of **MyApp**. The class has to  extends **WebHandler** class which is the base class for all server side applications handling clients requests. The starting definition of this class is as follows:

.. code:: python

  from WebAppDIRAC.Lib.WebHandler import WebHandler

  class MyAppHandler(WebHandler):

For each type of client request there must be an **entry point** i.e. a method that will be invoked when a clients' requests arrive at the server. Lets say that the URL of the requested method is **MyApp/getData**. Therefore the name of the class is **MyAppHandler** and the name of the method within the class will be **web_getData**. This means that if you want a method to be accessible in the application class you have to put the prefix **"web_"** to the name of the method.

.. code:: python

  from WebAppDIRAC.Lib.WebHandler import WebHandler

  class MyAppHandler(WebHandler):
    def web_getData(self):
      self.write({“data”:[1,2,3,4]})

In order to send back response to the client, we can use the **write** method of the **WebHandler** class. This method whenever invoked, sends to the client the value given as a parameter. If the value  is of type dictionary, then the dictionary is converted to JSON string before it is sent back to the client.

The server handles all requests one-by-one which means that the server does not handle the next request until the current one is finished. This mechanism becomes a bottleneck if one request lasts longer and increases the response time for each subsequent request waiting in the server queue until the previous one has finished. Thus the server provides a way how to asynchronously handle clients' requests and mitigate this obstacle. Read the following link and tutorial for further information  [https://github.com/DIRACGrid/WebAppDIRAC/wiki/Asynchronous-handling-mechanisms-of-clients%27-requests].

Any other method that is not an entry point, can have any arbitrary name satisfying the rules of the Python programming language.

Usually the clients requests come with parameters that contain data. In order to access a parameter, you have to use the following expression:

.. code:: python

  self.request.arguments["parameter_name"][0]

or in a full example

.. code:: python

  def web_ping(self):
    pingValue = self.request.arguments["ping_val"][0]
    self.write({"pong_val": pingValue})

Every parameter value is enclosed by a list by default so the 0-index stands for taking the value out of the list.

Client Side
-----------------

The CS side consists of files needed for rendering the UI and communicating with the server side. Technologies used are JavaScript with ExtJS4.x, HTML and CSS. The files of the CS are located into the **static/<Module name folder such as DIRAC, LHCbDIRAC, WebAppDIRAC>** folder and are organized as follows:

- **MyApp** : this folder is named after the name of the application we want to build. It contains all the files regarding this application.

  - **build**: this folder contains the compiled version of the javascript files contained in the classes 
folder

  - **classes**: this folder contains the javascript file that defines the main ExtJS class representing the application on the client side.

    - **MyApp.js**: this mandatory file contains the main ExtJS class representing the application on the client side. The name of the file must have the same name as the application we want to build. 

  - **css**: this folder contains all the css files specific to this application.

    - **MyApp.css**:  this mandatory file contains the css style needed by some of the components of the application. The name of the file must have the same name as the application we want to build. The file must be created no matter it contains some code or not.

  - **images**: this folder contains all the specific images and icons needed by this application.

The most important part of all files and folders is the file that contains the main ExtJS class representing the application on the client side (in our case that is MyApp.js). 

This file defines a ExtJS class responsible for all client side functionality of MyApp. This class extends **Ext.dirac.core.Module** class which is the base class for all applications. The starting definition of this class is as follows:
::

  Ext.define('DIRAC.MyApp.classes.MyApp', {
    extend : 'Ext.dirac.core.Module',
    requires :[]
  }); 

When extending the base class, there are some mandatory methods to be implemented within the derived class:

- **initComponent**: this method is called by the constructor of the application. In this method you can set up the title of the application, its width and height, its maximized state, starting position on the screen and the icon css class. Here it is suitable to set up the layout of the entire application. For further information regarding ExtJS component layouts refer to http://docs.sencha.com/extjs/4.2.1/extjs-build/examples/layout-browser/layout-browser.html.

- **buildUI**: this method is used to build the user interface. Usually this is done by instantiating ExtJS widgets. These instances are added to the application in a way prescribed by the layout which is defined in the initComponent method. This method is called after all the CSS files regarding this application have been successfully loaded.

- **getStateData**: The DIRAC web framework provides a generic way to save and load states of an application. This method is not mandatory, and it can be overridden by a new implementation in the application class. Whenever the user saves an application state, this method is called in order to take the data defining the current state of the application. The data has to be a JavaScript object. 

- **loadState(data)**: When we want to load a state, this method is being called. As an argument the framework provides the data that have been saved previously for that state.

The framework already defines handlers for some events related to the windows instances in which the applications are loaded. However there are cases when the developer would like to define some additional actions that have to be executed when those events appear.

In order to access the window object containing the instance of an application, you can use the method **getContainer()**. When having a reference pointing to the window instance, you can define additional functions to be executed when some events related to the window widget appear. Namely those extra event handlers are as follow:

- **__dirac_activate**: called in the window handler for the **activate** event

- **__dirac_beforeshow**: called in the window handler for the **beforeshow** event

- **__dirac_afterrender**: called in the window handler for the **afterrender** event

- **__dirac_minimize**: called in the window handler for the **minimize** event

- **__dirac_maximize**: called in the window handler for the **maximize** event

- **__dirac_restore**: called in the window handler for the **restore** event

- **__dirac_destroy**: called in the window handler for the **destroy** event

- **__dirac_boxready**: called in the window handler for the **boxready** event

- **__dirac_move**: called in the window handler for the **move** event

- **__dirac_resize**: called in the window handler for the **resize** event

For example, suppose we have an image shown inside an application. Suppose we want to resize the image whenever the window gets resized. So the code that we need in order to support this functionality is as follows (in the following code **this** refers to the application object):
::

  this.getContainer().__dirac_resize = function(oWindow, iWidth, iHeight, eOpts) {
		this.__oprResizeImageAccordingToWindow(image, oWindow);
  }

DIRAC reserved variables and constants
#######################################

The DIRAC web framework provides a set of global variables and constants. These constants and variables can be accessed anywhere in the code.

- **GLOBAL.APP**: A reference to the main object representing the entire framework. The most important references provided by this reference are as follows:

  - **GLOBAL.APP.desktop**: A reference to the desktop object

  - **GLOBAL.APP.SM**: A reference to the state management object responsible for saving, loading, managing active state, creating and loading user interface forms related to the state management.

  - **GLOBAL.APP.CF**: A reference to the object providing common functions that can be used by applications.

- **GLOBAL.BASE_URL**: Base URL that has to be used when requesting a service from the server.

- **GLOBAL.EXTJS_VERSION**: The version of the ExtJS library

- **GLOBAL.MOUSE_X**: The X coordinate of the mouse cursor relative to the top left corner of the presentation area of the browser.

- **GLOBAL.MOUSE_Y**: The Y coordinate of the mouse cursor relative to the top left corner of the presentation area of the browser.

- **GLOBAL.IS_IE**: An indicator whether the browser embedding the system is Internet Explorer or not.

- **GLOBAL.USER_CREDENTIALS**: A reference to an object containing the user credentials.

- **GLOBAL.STATE_MANAGEMENT_ENABLED**: An indicator whether the state management is available or not.

Useful components
##################

When building the client side, you can use some additional components that are not part of the standard ExtJS set of components. These components were especially designed for the framework and the applications and can be found in **<Module name folder such as DIRAC, LHCbDIRAC, WebAppDIRAC>/WebApp/static/core/js/utils**:

- **DiracBoxSelect**: This component looks like the standard combo-box component, but provides more functionality. Main features: supporting of multichecking, searching through the options, and making negation of the selection. You can see an example of this component within the left panel of the JobMonitor application.

- **DiracFileLoad**: Whenever you want to load an extra JavaScript file or CSS file, but also you want to define a callback upon successful loading of the file, this is the right component for doing this.

- **DiracToolButton**: This component represents a small squared button providing possibility to define menu. This button is suitable for buttons that should take small space in cases such as headers of others components. You can see an example of this component at the header of left panel of the JobMonitor.